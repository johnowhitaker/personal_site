{"title":"Tutorial: Improving Crop Type Predictions","markdown":{"yaml":{"title":"Tutorial: Improving Crop Type Predictions","date":"2019-06-27","categories":["tutorials"]},"headingText":"Improving the input data for the classifier","containsRefs":false,"markdown":"\n\nFollowing on from the last tutorial, this post will look at some ways we can improve our crop identification method. At the end of the last post, we were using a CART classifier to classify crops based on a greenest-pixel composite made from landsat 8 imagery. It didn't do too well compared to other submissions, and the classifier was getting around 65% accuracy on the training data. Let's start fixing some of the more obvious errors.\n\n\nUsing a greenest-pixel composite was an easy first step. However, the competition is focused on a single year (2017), while the composite image likely drew data from previous years. And, with a single composite image, any growth cycles or seasonal variation between the different crops is lost. This leads to our first major improvement: using images from different times of year and combining them into one input image that preserves the seasonal changes.\n\n![](images/screenshot-from-2019-06-26-18-05-43.png)\n\nBest quality landsat imagery from Jan-March 2017, one of the new model inputs\n\nThe [new Earth Engine code](https://code.earthengine.google.com/563621fb2a09a2682672541f6af1c228) filters the available Landsat imagery by date, splitting it into 4-month sections. The earliest high-quality imagery from each time period is selected (based on the code in [this guide](https://developers.google.com/earth-engine/ic_composite_mosaic)). Once this step is complete, the images are combined int a single new image that maintains the bands from each. The result is an image with 28 bands, which will be sampled and used by the model.\n\n![](images/screenshot-from-2019-06-26-18-10-46.png)\n\nMerging the images into one\n\nUsing the resultant merged image in place of the greenest-pixel composite, a CART classifier now achieves an accuracy of 76% on the training data, and scores 16.56 on the test data - an improvement over our previous score for this model. A randomForest classifier with 100 trees does even better, bringing the score down to 13.56, our new best.\n\n## Training models and making predictions locally for faster iteration\n\nSo far, we've been using GEE's classifiers and making predictions over the whole area, then sampling the predictions to get a single class as our final prediction. Instead, let's sample the landsat data for each polygon in the train and test sets, download that data and use it to train models locally. This will be make experimenting with different models much faster.\n\nThe full code is [here](https://code.earthengine.google.com/953e305ff85af75a94ccabc7e9c0c829), and by taking the median value for each band of the merged image for each region of the training and test datasets, we get a pair of CSV files that we can easily load into Pandas for further analysis.\n\n![](images/screenshot-from-2019-06-26-19-27-47.png)\n\nLoading the data\n\nBefore experimenting with different models, optimizing parameters and so on, the first thing I tried was switching from predicting a single output class to predicting the probabilities that a given set of inputs belong to each of the different classes. Using the RandomForestClassifier from Scikit-learn, this is as simple as calling predict\\_proba(X) instead of predict(X). This gives a submission file much closer to the example provided by Zindi:\n\n![](images/screenshot-from-2019-06-27-07-53-52.png)\n\n_Predicting probability for each class_\n\nSo how does this new, improved submission score? **1.48**! We've jumped from near-last to top 50% (15'th as of today) _while still not using the provided satellite data!_\n\n## Model Tuning\n\nJust for fun, let's see how good we can get. Instead of submitting to Zindi to get a score (limited to 5 a day), we need a way to compare models locally, ideally with the same metric the contest uses. Fortunately, they're open about the scoring method - it's based on log-loss. By splitting the training data, using part to train a model and the rest to test it, we can get a rough idea of what out model would score:\n\n![](images/screenshot-from-2019-06-27-08-01-35.png)\n\nScoring a model with log\\_loss\n\nThe score depends on the test/train split. For better accuracy, we can average the scores with several different test/train splits. With a scoring method in place, we can start optimizing our models. As an example, we can pick the number of trees to use with the random forest model by plotting how the scores change with more estimators. In this case, anything above 200 looks to provide minimal extra advantage.\n\n![](images/rf_n_trees.png)\n\nWith Random Forest bottoming out at ~1.4 after some tweaking, I turned to XGBoost. A nice summary of tuning XGBoost can be found [here](https://towardsdatascience.com/fine-tuning-xgboost-in-python-like-a-boss-b4543ed8b1e). Starting with some suggested values and tweaking the max\\_depth and learning\\_rate parameters led me to a model that scored 1.15 in my tests - enough of an improvement that I made a submission using it's predictions on Zindi. Score: **1.51**. Pretty much the same as the Random Forest model.\n\n## Combining good models - Ensemble Modelling\n\nGiven several good models, can we get a better prediction by combining their outputs? This is a complex subject, but by simply taking the mean of the predictions made by my two best models, I achieved a score of **1.41** - 14'th place.\n\n## Conclusions\n\nThis GitHub repository contains the training and test datasets I generated with sampled Landsat data, as well as explanatory notebooks containing all the code described in this post. Feel free to follow along, make improvements and try it yourself. The key to further score improvements will be feature engineering - trying imagery from different time periods, adding features for plot area, distance to river, variation within the field etc. Lowering the scale variable in GEE to 30 will give slightly better data, as will sampling from the central areas of the fields. If I try any of these, I'll update this post.\n\nFor now, however, I am content. We've seen that it is possible to perform the specified task (crop identification) using nothing but some free Landsat data in GEE and some open source libraries to do the ML heavy lifting. While the fancy imagery provided is no doubt useful (see the top scores as evidence of this), this exercise shows that it is not essential to this kind of analysis. I hope that it inspires some of you to see what else is possible.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"2019-06-27-tutorial-improving-crop-type-predictions.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","theme":"cosmo","title":"Tutorial: Improving Crop Type Predictions","date":"2019-06-27","categories":["tutorials"]},"extensions":{"book":{"multiFile":true}}}}}